import { existsSync, mkdirSync } from 'fs';
import { join, basename } from 'path';
import { YtDlpWrapper } from '../utils/ytdlp.js';

export interface DownloadOptions {
  language?: string;
  format?: 'srt' | 'vtt' | 'json' | 'txt';
  outputDir?: string;
  autoGenerated?: boolean;
  listOnly?: boolean;
}

export class SubtitleDownloader {
  private ytdlp: YtDlpWrapper;

  constructor() {
    this.ytdlp = new YtDlpWrapper();
  }

  async checkDependencies(): Promise<void> {
    const isInstalled = await this.ytdlp.checkYtDlpInstalled();
    if (!isInstalled) {
      throw new Error('yt-dlp is not installed. Please install it first: pip install yt-dlp');
    }
  }

  private sanitizeFilename(filename: string): string {
    return filename.replace(/[<>:"/\\|?*]/g, '_').substring(0, 200);
  }

  private ensureOutputDir(outputDir: string): void {
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }
  }

  async downloadSubtitle(url: string, options: DownloadOptions = {}): Promise<string | string[]> {
    const {
      language = 'en',
      format = 'txt',
      outputDir = './downloads',
      autoGenerated = false,
      listOnly = false
    } = options;

    await this.checkDependencies();

    const videoInfo = await this.ytdlp.getVideoInfo(url);
    
    if (listOnly) {
      return this.ytdlp.listAvailableSubtitles(videoInfo);
    }

    this.ensureOutputDir(outputDir);

    const safeTitle = this.sanitizeFilename(videoInfo.title);
    const outputPath = join(outputDir, `${safeTitle}.${format}`);

    const subtitlePath = await this.ytdlp.downloadSubtitle(
      url,
      language,
      outputPath,
      format,
      autoGenerated
    );

    if (format === 'txt') {
      await this.convertSrtToTxt(subtitlePath);
    }

    return subtitlePath;
  }

  private async convertSrtToTxt(srtPath: string): Promise<string> {
    const { readFileSync, writeFileSync } = await import('fs');
    
    const txtPath = srtPath.replace(/\.srt$/, '.txt');
    
    try {
      const srtContent = readFileSync(srtPath, 'utf-8');
      const lines = srtContent.split('\n');
      const textLines: string[] = [];
      
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed && 
            !trimmed.match(/^\d+$/) && 
            !trimmed.match(/^\d{2}:\d{2}:\d{2},\d{3} --> \d{2}:\d{2}:\d{2},\d{3}$/)) {
          textLines.push(trimmed);
        }
      }
      
      const txtContent = textLines.join(' ').replace(/\s+/g, ' ').trim();
      writeFileSync(txtPath, txtContent, 'utf-8');
      
      return txtPath;
    } catch (error) {
      throw new Error(`Failed to convert SRT to TXT: ${error}`);
    }
  }

  async batchDownload(urls: string[], options: DownloadOptions = {}): Promise<Map<string, string | Error>> {
    const results = new Map<string, string | Error>();

    for (const url of urls) {
      try {
        const result = await this.downloadSubtitle(url, options);
        results.set(url, result as string);
      } catch (error) {
        results.set(url, error as Error);
      }
    }

    return results;
  }
}