import { existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { YtDlpWrapper } from '../utils/ytdlp.js';

export interface DownloadOptions {
  language?: string;
  format?: 'srt' | 'vtt' | 'json' | 'txt';
  outputDir?: string;
  autoGenerated?: boolean;
  listOnly?: boolean;
}

export class SubtitleDownloader {
  private ytdlp: YtDlpWrapper;

  constructor() {
    this.ytdlp = new YtDlpWrapper();
  }

  async checkDependencies(): Promise<void> {
    const isInstalled = await this.ytdlp.checkYtDlpInstalled();
    if (!isInstalled) {
      throw new Error(
        'yt-dlp is not installed. Please install it first: pip install yt-dlp'
      );
    }
  }

  private sanitizeFilename(filename: string): string {
    return filename.replace(/[<>:"/\\|?*]/g, '_').substring(0, 200);
  }

  private ensureOutputDir(outputDir: string): void {
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }
  }

  async downloadSubtitle(
    url: string,
    options: DownloadOptions = {}
  ): Promise<string | string[]> {
    const {
      language = 'en',
      format = 'txt',
      outputDir = './downloads',
      autoGenerated = false,
      listOnly = false,
    } = options;

    await this.checkDependencies();

    const videoInfo = await this.ytdlp.getVideoInfo(url);

    if (listOnly) {
      return this.ytdlp.listAvailableSubtitles(videoInfo);
    }

    this.ensureOutputDir(outputDir);

    const safeTitle = this.sanitizeFilename(videoInfo.title);
    const outputPath = join(outputDir, `${safeTitle}.${format}`);

    const subtitlePath = await this.ytdlp.downloadSubtitle(
      url,
      language,
      outputPath,
      format,
      autoGenerated
    );

    if (format === 'txt') {
      await this.convertSrtToTxt(subtitlePath);
    }

    return subtitlePath;
  }

  private async convertSrtToTxt(subtitlePath: string): Promise<string> {
    const { readFileSync, writeFileSync, existsSync } = await import('fs');

    // Handle both .srt and .vtt files
    const txtPath = subtitlePath.replace(/\.(srt|vtt)$/, '.txt');

    // Check if subtitle file exists
    if (!existsSync(subtitlePath)) {
      throw new Error(
        `Subtitle file not found: ${subtitlePath}\n` +
        `This usually means:\n` +
        `1. The video has no subtitles in the requested language\n` +
        `2. yt-dlp failed to download subtitles\n` +
        `3. Try using --auto flag for auto-generated subtitles`
      );
    }

    try {
      const content = readFileSync(subtitlePath, 'utf-8');
      const lines = content.split('\n');
      const textLines: string[] = [];

      // Skip VTT header if present
      let startIndex = 0;
      if (lines[0]?.trim() === 'WEBVTT') {
        startIndex = 1;
      }

      for (let i = startIndex; i < lines.length; i++) {
        const trimmed = lines[i].trim();
        if (
          trimmed &&
          !trimmed.match(/^\d+$/) && // Skip line numbers
          !trimmed.match(/^\d{2}:\d{2}:\d{2}[.,]\d{3} --> \d{2}:\d{2}:\d{2}[.,]\d{3}/) && // Skip timestamps (both SRT and VTT)
          !trimmed.startsWith('WEBVTT') && // Skip VTT header
          !trimmed.startsWith('Kind:') && // Skip VTT metadata
          !trimmed.startsWith('Language:') // Skip VTT metadata
        ) {
          // Remove VTT timestamp tags like <00:00:00.000> and <c> tags
          const cleanedLine = trimmed
            .replace(/<\d{2}:\d{2}:\d{2}\.\d{3}>/g, '') // Remove timestamps
            .replace(/<\/?c>/g, '') // Remove <c> and </c> tags
            .trim();
          
          if (cleanedLine) {
            textLines.push(cleanedLine);
          }
        }
      }

      const txtContent = textLines.join(' ').replace(/\s+/g, ' ').trim();
      writeFileSync(txtPath, txtContent, 'utf-8');

      return txtPath;
    } catch (error) {
      throw new Error(`Failed to convert SRT to TXT: ${error}`);
    }
  }

  async batchDownload(
    urls: string[],
    options: DownloadOptions = {}
  ): Promise<Map<string, string | Error>> {
    const results = new Map<string, string | Error>();

    for (const url of urls) {
      try {
        const result = await this.downloadSubtitle(url, options);
        results.set(url, result as string);
      } catch (error) {
        results.set(url, error as Error);
      }
    }

    return results;
  }
}
