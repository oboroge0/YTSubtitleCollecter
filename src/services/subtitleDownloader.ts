import { existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { YtDlpWrapper } from '../utils/ytdlp.js';

export interface DownloadOptions {
  language?: string;
  format?: 'srt' | 'vtt' | 'json' | 'txt';
  outputDir?: string;
  autoGenerated?: boolean;
  listOnly?: boolean;
}

export class SubtitleDownloader {
  private ytdlp: YtDlpWrapper;

  constructor() {
    this.ytdlp = new YtDlpWrapper();
  }

  async checkDependencies(): Promise<void> {
    const isInstalled = await this.ytdlp.checkYtDlpInstalled();
    if (!isInstalled) {
      throw new Error(
        'yt-dlp is not installed. Please install it first: pip install yt-dlp'
      );
    }
  }

  private sanitizeFilename(filename: string): string {
    // Windows-safe filename sanitization
    return filename
      .replace(/[<>:"/\\|?*\x00-\x1f]/g, '_') // Windows forbidden characters
      .replace(/[\u{1F600}-\u{1F64F}]/gu, '_') // Emoji
      .replace(/[\u{1F300}-\u{1F5FF}]/gu, '_') // Symbols & Pictographs
      .replace(/[\u{1F680}-\u{1F6FF}]/gu, '_') // Transport & Map
      .replace(/[\u{1F700}-\u{1F77F}]/gu, '_') // Alchemical Symbols
      .replace(/[\u{1F780}-\u{1F7FF}]/gu, '_') // Geometric Shapes Extended
      .replace(/[\u{1F800}-\u{1F8FF}]/gu, '_') // Supplemental Arrows-C
      .replace(/[\u{2600}-\u{26FF}]/gu, '_')   // Misc symbols
      .replace(/[\u{2700}-\u{27BF}]/gu, '_')   // Dingbats
      .replace(/[\u{FE00}-\u{FE0F}]/gu, '')    // Variation selectors
      .replace(/[\u{1F900}-\u{1F9FF}]/gu, '_') // Supplemental Symbols and Pictographs
      .replace(/[\u{1FA00}-\u{1FA6F}]/gu, '_') // Chess Symbols
      .replace(/[\u{1FA70}-\u{1FAFF}]/gu, '_') // Symbols and Pictographs Extended-A
      .replace(/【/g, '[')                      // Replace Japanese brackets
      .replace(/】/g, ']')
      .replace(/「/g, '[')
      .replace(/」/g, ']')
      .replace(/『/g, '[')
      .replace(/』/g, ']')
      .replace(/\s+/g, '_')                     // Replace spaces with underscore
      .replace(/_{2,}/g, '_')                   // Remove multiple underscores
      .replace(/^_+|_+$/g, '')                  // Trim underscores
      .substring(0, 150);                       // Limit length for Windows path limits
  }

  private ensureOutputDir(outputDir: string): void {
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }
  }

  async downloadSubtitle(
    url: string,
    options: DownloadOptions = {}
  ): Promise<string | string[]> {
    const {
      language = 'en',
      format = 'txt',
      outputDir = './downloads',
      autoGenerated = false,
      listOnly = false,
    } = options;

    await this.checkDependencies();

    const videoInfo = await this.ytdlp.getVideoInfo(url);

    if (listOnly) {
      return this.ytdlp.listAvailableSubtitles(videoInfo);
    }

    this.ensureOutputDir(outputDir);

    const safeTitle = this.sanitizeFilename(videoInfo.title);
    const outputPath = join(outputDir, `${safeTitle}.${format}`);

    const subtitlePath = await this.ytdlp.downloadSubtitle(
      url,
      language,
      outputPath,
      format,
      autoGenerated
    );

    if (format === 'txt') {
      await this.convertSrtToTxt(subtitlePath);
    }

    return subtitlePath;
  }

  private async convertSrtToTxt(subtitlePath: string): Promise<string> {
    const { readFileSync, writeFileSync, existsSync } = await import('fs');

    // Handle both .srt and .vtt files
    const txtPath = subtitlePath.replace(/\.(srt|vtt)$/, '.txt');

    // Check if subtitle file exists
    if (!existsSync(subtitlePath)) {
      throw new Error(
        `Subtitle file not found: ${subtitlePath}\n` +
        `This usually means:\n` +
        `1. The video has no subtitles in the requested language\n` +
        `2. yt-dlp failed to download subtitles\n` +
        `3. Try using --auto flag for auto-generated subtitles`
      );
    }

    try {
      const content = readFileSync(subtitlePath, 'utf-8');
      const lines = content.split('\n');
      const textLines: string[] = [];

      // Skip VTT header if present
      let startIndex = 0;
      if (lines[0]?.trim() === 'WEBVTT') {
        startIndex = 1;
      }

      for (let i = startIndex; i < lines.length; i++) {
        const trimmed = lines[i].trim();
        if (
          trimmed &&
          !trimmed.match(/^\d+$/) && // Skip line numbers
          !trimmed.match(/^\d{2}:\d{2}:\d{2}[.,]\d{3} --> \d{2}:\d{2}:\d{2}[.,]\d{3}/) && // Skip timestamps (both SRT and VTT)
          !trimmed.startsWith('WEBVTT') && // Skip VTT header
          !trimmed.startsWith('Kind:') && // Skip VTT metadata
          !trimmed.startsWith('Language:') // Skip VTT metadata
        ) {
          // Remove VTT timestamp tags like <00:00:00.000> and <c> tags
          const cleanedLine = trimmed
            .replace(/<\d{2}:\d{2}:\d{2}\.\d{3}>/g, '') // Remove timestamps
            .replace(/<\/?c>/g, '') // Remove <c> and </c> tags
            .trim();
          
          if (cleanedLine) {
            textLines.push(cleanedLine);
          }
        }
      }

      const txtContent = textLines.join(' ').replace(/\s+/g, ' ').trim();
      writeFileSync(txtPath, txtContent, 'utf-8');

      return txtPath;
    } catch (error) {
      throw new Error(`Failed to convert SRT to TXT: ${error}`);
    }
  }

  async batchDownload(
    urls: string[],
    options: DownloadOptions = {}
  ): Promise<Map<string, string | Error>> {
    const results = new Map<string, string | Error>();

    for (const url of urls) {
      try {
        const result = await this.downloadSubtitle(url, options);
        results.set(url, result as string);
      } catch (error) {
        results.set(url, error as Error);
      }
    }

    return results;
  }
}
