import { spawn } from 'child_process';
import { promisify } from 'util';
import { exec } from 'child_process';

const execAsync = promisify(exec);

export interface SubtitleInfo {
  language: string;
  ext: string;
  url?: string;
  name?: string;
}

export interface VideoInfo {
  title: string;
  uploader: string;
  duration: number;
  subtitles: Record<string, SubtitleInfo[]>;
  automatic_captions: Record<string, SubtitleInfo[]>;
}

export class YtDlpWrapper {
  private ytDlpPath: string = 'yt-dlp';

  async checkYtDlpInstalled(): Promise<boolean> {
    try {
      await execAsync(`${this.ytDlpPath} --version`);
      return true;
    } catch {
      return false;
    }
  }

  async getVideoInfo(url: string): Promise<VideoInfo> {
    return new Promise((resolve, reject) => {
      const args = ['--dump-json', '--no-warnings', '--no-playlist', url];

      // Use shell option on Windows to handle Unicode properly
      const isWindows = process.platform === 'win32';
      const spawnOptions = isWindows ? { shell: true, windowsVerbatimArguments: true } : {};
      
      const ytdlp = spawn(this.ytDlpPath, args, spawnOptions);
      let stdout = '';
      let stderr = '';

      ytdlp.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      ytdlp.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      ytdlp.on('close', (code) => {
        if (code !== 0) {
          reject(new Error(`yt-dlp exited with code ${code}: ${stderr}`));
          return;
        }

        try {
          const info = JSON.parse(stdout);
          resolve({
            title: info.title || 'Unknown',
            uploader: info.uploader || 'Unknown',
            duration: info.duration || 0,
            subtitles: info.subtitles || {},
            automatic_captions: info.automatic_captions || {},
          });
        } catch (error) {
          reject(new Error(`Failed to parse video info: ${error}`));
        }
      });

      ytdlp.on('error', (error) => {
        reject(new Error(`Failed to spawn yt-dlp: ${error.message}`));
      });
    });
  }

  async downloadSubtitle(
    url: string,
    language: string,
    outputPath: string,
    _format: 'srt' | 'vtt' | 'json' | 'txt' = 'txt',
    autoGenerated: boolean = false
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const args = [
        autoGenerated ? '--write-auto-sub' : '--write-sub',
        '--sub-lang',
        language,
        '--skip-download',
        '--no-warnings',
        '--no-playlist',
        '-o',
        outputPath,
        url,
      ];

      console.log(`[DEBUG] Running: yt-dlp ${args.join(' ')}`);

      // Use shell option on Windows to handle Unicode properly
      const isWindows = process.platform === 'win32';
      const spawnOptions = isWindows ? { shell: true, windowsVerbatimArguments: true } : {};
      
      const ytdlp = spawn(this.ytDlpPath, args, spawnOptions);
      let stdout = '';
      let stderr = '';

      ytdlp.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      ytdlp.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      ytdlp.on('close', (code) => {
        if (code !== 0) {
          let errorMessage = `yt-dlp failed (exit code ${code})\n`;
          
          // Parse common error messages
          if (stderr.includes('did not get any data blocks')) {
            errorMessage += `\nNo subtitle data found. Possible reasons:\n`;
            errorMessage += `1. The video has no ${autoGenerated ? 'auto-generated' : 'manual'} subtitles in '${language}'\n`;
            errorMessage += `2. Try ${autoGenerated ? 'without' : 'with'} the --auto flag\n`;
            errorMessage += `3. Check available subtitles with --list flag\n`;
          } else if (stderr.includes('Requested format is not available')) {
            errorMessage += `\nSubtitle format '${language}' is not available\n`;
          } else {
            errorMessage += `\nError: ${stderr}\n`;
          }
          
          errorMessage += `\nOutput: ${stdout}\n`;
          errorMessage += `Command: yt-dlp ${args.join(' ')}`;
          
          reject(new Error(errorMessage));
          return;
        }

        // yt-dlp outputs .vtt by default and includes the original extension
        const actualFormat = 'vtt';
        const expectedPath = outputPath + `.${language}.${actualFormat}`;

        console.log(`[DEBUG] Expected subtitle file: ${expectedPath}`);
        resolve(expectedPath);
      });

      ytdlp.on('error', (error) => {
        reject(new Error(`Failed to spawn yt-dlp: ${error.message}`));
      });
    });
  }

  listAvailableSubtitles(videoInfo: VideoInfo): string[] {
    const subtitles = new Set<string>();

    Object.keys(videoInfo.subtitles).forEach((lang) => {
      subtitles.add(lang);
    });

    Object.keys(videoInfo.automatic_captions).forEach((lang) => {
      subtitles.add(lang + ' (auto)');
    });

    return Array.from(subtitles);
  }
}
