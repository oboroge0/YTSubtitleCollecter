import { spawn } from 'child_process';
import { promisify } from 'util';
import { exec } from 'child_process';

const execAsync = promisify(exec);

export interface SubtitleInfo {
  language: string;
  ext: string;
  url?: string;
  name?: string;
}

export interface VideoInfo {
  title: string;
  uploader: string;
  duration: number;
  subtitles: Record<string, SubtitleInfo[]>;
  automatic_captions: Record<string, SubtitleInfo[]>;
}

export class YtDlpWrapper {
  private ytDlpPath: string = 'yt-dlp';

  async checkYtDlpInstalled(): Promise<boolean> {
    try {
      await execAsync(`${this.ytDlpPath} --version`);
      return true;
    } catch {
      return false;
    }
  }

  async getVideoInfo(url: string): Promise<VideoInfo> {
    return new Promise((resolve, reject) => {
      const args = ['--dump-json', '--no-warnings', '--no-playlist', url];

      const ytdlp = spawn(this.ytDlpPath, args);
      let stdout = '';
      let stderr = '';

      ytdlp.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      ytdlp.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      ytdlp.on('close', (code) => {
        if (code !== 0) {
          reject(new Error(`yt-dlp exited with code ${code}: ${stderr}`));
          return;
        }

        try {
          const info = JSON.parse(stdout);
          resolve({
            title: info.title || 'Unknown',
            uploader: info.uploader || 'Unknown',
            duration: info.duration || 0,
            subtitles: info.subtitles || {},
            automatic_captions: info.automatic_captions || {},
          });
        } catch (error) {
          reject(new Error(`Failed to parse video info: ${error}`));
        }
      });

      ytdlp.on('error', (error) => {
        reject(new Error(`Failed to spawn yt-dlp: ${error.message}`));
      });
    });
  }

  async downloadSubtitle(
    url: string,
    language: string,
    outputPath: string,
    format: 'srt' | 'vtt' | 'json' | 'txt' = 'txt',
    autoGenerated: boolean = false
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const args = [
        '--write-sub',
        autoGenerated ? '--write-auto-sub' : '--no-write-auto-sub',
        '--sub-lang',
        language,
        '--sub-format',
        format === 'txt' ? 'srt' : format,
        '--skip-download',
        '--no-warnings',
        '--no-playlist',
        '-o',
        outputPath,
        url,
      ];

      const ytdlp = spawn(this.ytDlpPath, args);
      let stderr = '';

      ytdlp.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      ytdlp.on('close', (code) => {
        if (code !== 0) {
          reject(new Error(`yt-dlp exited with code ${code}: ${stderr}`));
          return;
        }

        const expectedPath =
          format === 'txt'
            ? outputPath.replace(/\.[^/.]+$/, '') + `.${language}.srt`
            : outputPath.replace(/\.[^/.]+$/, '') + `.${language}.${format}`;

        resolve(expectedPath);
      });

      ytdlp.on('error', (error) => {
        reject(new Error(`Failed to spawn yt-dlp: ${error.message}`));
      });
    });
  }

  listAvailableSubtitles(videoInfo: VideoInfo): string[] {
    const subtitles = new Set<string>();

    Object.keys(videoInfo.subtitles).forEach((lang) => {
      subtitles.add(lang);
    });

    Object.keys(videoInfo.automatic_captions).forEach((lang) => {
      subtitles.add(lang + ' (auto)');
    });

    return Array.from(subtitles);
  }
}
